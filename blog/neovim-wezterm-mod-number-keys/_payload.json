[{"data":1,"prerenderedAt":657},["ShallowReactive",2],{"navigation":3,"/blog/neovim-wezterm-mod-number-keys":50,"/blog/neovim-wezterm-mod-number-keys-surround":652},[4],{"title":5,"path":6,"stem":7,"children":8,"page":49},"Blog","/blog","blog",[9,13,17,21,25,29,33,37,41,45],{"title":10,"path":11,"stem":12},"Third post","/blog/_lorem-ipsum","blog/_lorem-ipsum",{"title":14,"path":15,"stem":16},"Markdown Style Guide","/blog/_markdown-style-guide","blog/_markdown-style-guide",{"title":18,"path":19,"stem":20},"Remote Debugging Addon for Blender","/blog/blender-debugger","blog/blender-debugger",{"title":22,"path":23,"stem":24},"How to use Dynamic Variables with Tailwind","/blog/dynamic-tailwind","blog/dynamic-tailwind",{"title":26,"path":27,"stem":28},"Krita Popup Palette Improvements","/blog/krita-brush-pr","blog/krita-brush-pr",{"title":30,"path":31,"stem":32},"How to map Mod+Number keys in Vim/Neovim (using Wezterm)","/blog/neovim-wezterm-mod-number-keys","blog/neovim-wezterm-mod-number-keys",{"title":34,"path":35,"stem":36},"Abusing Typescript's New `satisfies` Operator","/blog/satisfies","blog/satisfies",{"title":38,"path":39,"stem":40},"How to Publish v0.x.x Versioned Packages with Semantic Release","/blog/semantic-release-v0","blog/semantic-release-v0",{"title":42,"path":43,"stem":44},"I cave, Tailwind rocks.","/blog/tailwind-rocks","blog/tailwind-rocks",{"title":46,"path":47,"stem":48},"How To Add Tests To A Zig Project","/blog/zig-testing","blog/zig-testing",false,{"id":51,"title":30,"body":52,"date":642,"description":643,"extension":644,"image":645,"langs":646,"meta":647,"navigation":236,"path":31,"published":236,"seo":648,"stem":32,"tags":649,"__hash__":651},"blog/blog/neovim-wezterm-mod-number-keys.md",{"type":53,"value":54,"toc":640},"minimark",[55,59,70,79,87,96,111,118,121,124,386,396,399,601,604,633,636],[56,57,58],"p",{},"I've been recently giving neovim a serious try (this is my fourth/fifth attempt). And I think this time it's going to work out, but I really miss Modifier+Number shortcuts.",[56,60,61,62,69],{},"Usually you cannot map to modifies + number keys in in neovim (e.g. Ctrl+1). You can ",[63,64,68],"a",{"href":65,"rel":66},"https://vi.stackexchange.com/questions/19358/cannot-map-ctrl-number-except-6-or",[67],"nofollow","try to map the raw key sequences"," but this is a pain and does not work for all numbers.",[56,71,72,73,78],{},"The best way to get around this is to map to an obscure keybinding then make the terminal remap Mod+Number to those odd keybindings. I never got around to actually doing this usually because most terminal's configs are static it's also often a pain to remap keys (e.g. ",[63,74,77],{"href":75,"rel":76},"https://sw.kovidgoyal.net/kitty/conf/#shortcut-kitty.Send-arbitrary-text-on-key-presses",[67],"kitty, I like you, but...",")",[56,80,81,82,86],{},"Also the ideal way to do this is to map them to a key chain like ",[83,84,85],"code",{},"{ObscureCombo} {Mods}+{Remap}"," so as to not take up useful keys. But that's even more painful.",[56,88,89,90,95],{},"Recently though I tried and switched to ",[63,91,94],{"href":92,"rel":93},"https://github.com/wez/wezterm",[67],"wezterm"," for my terminal emulator, and it's configured through lua which makes this super easy to do for all sequences.",[56,97,98,99,102,103,106,107,110],{},"For example, I picked ",[83,100,101],{},"Ctrl+Alt+Shift+F12"," for the obscure key combo and letters for the remap part. So ",[83,104,105],{},"Ctrl+1"," would map to ",[83,108,109],{},"Ctrl+Alt+Shift+F12 Ctrl+q",".",[56,112,113,114,117],{},"The letter mapping is to avoid breaking anything. If we mapped them to, for example, the F keys again, we might accidentally shoot ourselves in the foot when pressing ",[83,115,116],{},"Alt+4"," .",[56,119,120],{},"Note that we also can't map the numbers without the modifiers, since wezterm has no way to know if we're in normal mode or not, and we would be left unable to type numbers if we did so.",[56,122,123],{},"Here's my wezterm function for remapping with all mods.",[125,126,131],"pre",{"className":127,"code":128,"language":129,"meta":130,"style":130},"language-lua shiki shiki-themes material-theme-lighter material-theme material-theme-palenight","-- Allows using Mods+Number in the receiving program if it does not support it.\n-- In the receiving program, the keymap needs to be `\u003CC-A-S-F12> \u003CMods-F{q-p}>`\nlocal remapModNumber = function(keyConfig, modsToRemap)\n    -- it's not \u003CMods-F{Number}> for obvious reasons (i.e. A-F4)\n    local numMap = {\n        [\"1\"] = \"q\",\n        [\"2\"] = \"w\",\n        [\"3\"] = \"e\",\n        [\"4\"] = \"r\",\n        [\"5\"] = \"t\",\n        [\"6\"] = \"y\",\n        [\"7\"] = \"u\",\n        [\"8\"] = \"i\",\n        [\"9\"] = \"o\",\n        [\"0\"] = \"p\",\n    }\n\n    local createModNumberRemap = function(key, mods)\n        local res = {\n            key = key,\n            mods = mods,\n            action = act.Multiple({\n                --obscure key to use as base\n                act.SendKey({ key = \"F12\", mods = \"CTRL|SHIFT|ALT\" }),\n                act.SendKey({ key = numMap[key], mods = mods }),\n            }),\n        }\n        return res\n    end\n    print(keyConfig)\n    for i = 0, 9 do\n        for _, mod in ipairs(modsToRemap) do\n            -- cant insert normally???\n            keyConfig[#keyConfig + 1] = createModNumberRemap(tostring(i), mod)\n        end\n    end\nend\nconfig.keys = {\n    -- ...your other keybindings\n}\n\nremapModNumber(config.keys, { \"CTRL\", \"SHIFT\", \"ALT\", \"CTRL|ALT\", \"ALT|SHIFT\", \"CTRL|SHIFT\", \"ALT|CTRL\", \"CTRL|SHIFT|ALT\" })\n","lua","",[83,132,133,141,147,153,159,165,171,177,183,189,195,201,207,213,219,225,231,238,244,250,256,262,268,274,280,286,292,298,304,310,316,322,328,334,340,346,351,357,363,369,375,380],{"__ignoreMap":130},[134,135,138],"span",{"class":136,"line":137},"line",1,[134,139,140],{},"-- Allows using Mods+Number in the receiving program if it does not support it.\n",[134,142,144],{"class":136,"line":143},2,[134,145,146],{},"-- In the receiving program, the keymap needs to be `\u003CC-A-S-F12> \u003CMods-F{q-p}>`\n",[134,148,150],{"class":136,"line":149},3,[134,151,152],{},"local remapModNumber = function(keyConfig, modsToRemap)\n",[134,154,156],{"class":136,"line":155},4,[134,157,158],{},"    -- it's not \u003CMods-F{Number}> for obvious reasons (i.e. A-F4)\n",[134,160,162],{"class":136,"line":161},5,[134,163,164],{},"    local numMap = {\n",[134,166,168],{"class":136,"line":167},6,[134,169,170],{},"        [\"1\"] = \"q\",\n",[134,172,174],{"class":136,"line":173},7,[134,175,176],{},"        [\"2\"] = \"w\",\n",[134,178,180],{"class":136,"line":179},8,[134,181,182],{},"        [\"3\"] = \"e\",\n",[134,184,186],{"class":136,"line":185},9,[134,187,188],{},"        [\"4\"] = \"r\",\n",[134,190,192],{"class":136,"line":191},10,[134,193,194],{},"        [\"5\"] = \"t\",\n",[134,196,198],{"class":136,"line":197},11,[134,199,200],{},"        [\"6\"] = \"y\",\n",[134,202,204],{"class":136,"line":203},12,[134,205,206],{},"        [\"7\"] = \"u\",\n",[134,208,210],{"class":136,"line":209},13,[134,211,212],{},"        [\"8\"] = \"i\",\n",[134,214,216],{"class":136,"line":215},14,[134,217,218],{},"        [\"9\"] = \"o\",\n",[134,220,222],{"class":136,"line":221},15,[134,223,224],{},"        [\"0\"] = \"p\",\n",[134,226,228],{"class":136,"line":227},16,[134,229,230],{},"    }\n",[134,232,234],{"class":136,"line":233},17,[134,235,237],{"emptyLinePlaceholder":236},true,"\n",[134,239,241],{"class":136,"line":240},18,[134,242,243],{},"    local createModNumberRemap = function(key, mods)\n",[134,245,247],{"class":136,"line":246},19,[134,248,249],{},"        local res = {\n",[134,251,253],{"class":136,"line":252},20,[134,254,255],{},"            key = key,\n",[134,257,259],{"class":136,"line":258},21,[134,260,261],{},"            mods = mods,\n",[134,263,265],{"class":136,"line":264},22,[134,266,267],{},"            action = act.Multiple({\n",[134,269,271],{"class":136,"line":270},23,[134,272,273],{},"                --obscure key to use as base\n",[134,275,277],{"class":136,"line":276},24,[134,278,279],{},"                act.SendKey({ key = \"F12\", mods = \"CTRL|SHIFT|ALT\" }),\n",[134,281,283],{"class":136,"line":282},25,[134,284,285],{},"                act.SendKey({ key = numMap[key], mods = mods }),\n",[134,287,289],{"class":136,"line":288},26,[134,290,291],{},"            }),\n",[134,293,295],{"class":136,"line":294},27,[134,296,297],{},"        }\n",[134,299,301],{"class":136,"line":300},28,[134,302,303],{},"        return res\n",[134,305,307],{"class":136,"line":306},29,[134,308,309],{},"    end\n",[134,311,313],{"class":136,"line":312},30,[134,314,315],{},"    print(keyConfig)\n",[134,317,319],{"class":136,"line":318},31,[134,320,321],{},"    for i = 0, 9 do\n",[134,323,325],{"class":136,"line":324},32,[134,326,327],{},"        for _, mod in ipairs(modsToRemap) do\n",[134,329,331],{"class":136,"line":330},33,[134,332,333],{},"            -- cant insert normally???\n",[134,335,337],{"class":136,"line":336},34,[134,338,339],{},"            keyConfig[#keyConfig + 1] = createModNumberRemap(tostring(i), mod)\n",[134,341,343],{"class":136,"line":342},35,[134,344,345],{},"        end\n",[134,347,349],{"class":136,"line":348},36,[134,350,309],{},[134,352,354],{"class":136,"line":353},37,[134,355,356],{},"end\n",[134,358,360],{"class":136,"line":359},38,[134,361,362],{},"config.keys = {\n",[134,364,366],{"class":136,"line":365},39,[134,367,368],{},"    -- ...your other keybindings\n",[134,370,372],{"class":136,"line":371},40,[134,373,374],{},"}\n",[134,376,378],{"class":136,"line":377},41,[134,379,237],{"emptyLinePlaceholder":236},[134,381,383],{"class":136,"line":382},42,[134,384,385],{},"remapModNumber(config.keys, { \"CTRL\", \"SHIFT\", \"ALT\", \"CTRL|ALT\", \"ALT|SHIFT\", \"CTRL|SHIFT\", \"ALT|CTRL\", \"CTRL|SHIFT|ALT\" })\n",[56,387,388,389,392,393,110],{},"Then in vim, if we wanted to use ",[83,390,391],{},"\u003CC-1>"," we would map to ",[83,394,395],{},"\u003CC-S-A-F12>\u003CC-q>",[56,397,398],{},"I've also added a small helper function in my local utils module to help with this. I might extract this later into a plugin.",[125,400,402],{"className":127,"code":401,"language":129,"meta":130,"style":130},"local M = {}\nlocal config = {\n    baseSequence = \"\u003CC-S-A-F12>\",\n}\nM.setup = function(opts)\n    opts = opts or {}\n    vim.tbl_extend(\"force\", config, opts)\nend\nlocal replacements = {\n    [\"1\"] = \"q\",\n    [\"2\"] = \"w\",\n    [\"3\"] = \"e\",\n    [\"4\"] = \"r\",\n    [\"5\"] = \"t\",\n    [\"6\"] = \"y\",\n    [\"7\"] = \"u\",\n    [\"8\"] = \"i\",\n    [\"9\"] = \"o\",\n    [\"0\"] = \"p\",\n}\nM.mapNum = function(keysString)\n    local str = \"\"\n    for i = 1, #keysString do\n        local prevPrevChar = i > 2 and keysString:sub(i - 2, i - 2) or nil\n\n        local prevChar = i > 1 and keysString:sub(i - 1, i - 1) or nil\n        local char = keysString:sub(i, i)\n        local isNumber = tonumber(char) ~= nil\n        local prevIsNumber = prevChar ~= nil and tonumber(prevChar) ~= nil\n        local prevIsAllowed = prevChar == nil or prevChar ~= \"F\" or prevIsNumber\n        local prevPrevIsAllowed = prevPrevChar == nil or prevPrevChar ~= \"F\"\n        if isNumber and prevIsAllowed and prevPrevIsAllowed then\n            str = str .. replacements[char]\n        else\n            str = str .. char\n        end\n    end\n    return config.baseSequence .. str\nend\n\nreturn M\n",[83,403,404,409,414,419,423,428,433,438,442,447,452,457,462,467,472,477,482,487,492,497,501,506,511,516,521,525,530,535,540,545,550,555,560,565,570,575,579,583,588,592,596],{"__ignoreMap":130},[134,405,406],{"class":136,"line":137},[134,407,408],{},"local M = {}\n",[134,410,411],{"class":136,"line":143},[134,412,413],{},"local config = {\n",[134,415,416],{"class":136,"line":149},[134,417,418],{},"    baseSequence = \"\u003CC-S-A-F12>\",\n",[134,420,421],{"class":136,"line":155},[134,422,374],{},[134,424,425],{"class":136,"line":161},[134,426,427],{},"M.setup = function(opts)\n",[134,429,430],{"class":136,"line":167},[134,431,432],{},"    opts = opts or {}\n",[134,434,435],{"class":136,"line":173},[134,436,437],{},"    vim.tbl_extend(\"force\", config, opts)\n",[134,439,440],{"class":136,"line":179},[134,441,356],{},[134,443,444],{"class":136,"line":185},[134,445,446],{},"local replacements = {\n",[134,448,449],{"class":136,"line":191},[134,450,451],{},"    [\"1\"] = \"q\",\n",[134,453,454],{"class":136,"line":197},[134,455,456],{},"    [\"2\"] = \"w\",\n",[134,458,459],{"class":136,"line":203},[134,460,461],{},"    [\"3\"] = \"e\",\n",[134,463,464],{"class":136,"line":209},[134,465,466],{},"    [\"4\"] = \"r\",\n",[134,468,469],{"class":136,"line":215},[134,470,471],{},"    [\"5\"] = \"t\",\n",[134,473,474],{"class":136,"line":221},[134,475,476],{},"    [\"6\"] = \"y\",\n",[134,478,479],{"class":136,"line":227},[134,480,481],{},"    [\"7\"] = \"u\",\n",[134,483,484],{"class":136,"line":233},[134,485,486],{},"    [\"8\"] = \"i\",\n",[134,488,489],{"class":136,"line":240},[134,490,491],{},"    [\"9\"] = \"o\",\n",[134,493,494],{"class":136,"line":246},[134,495,496],{},"    [\"0\"] = \"p\",\n",[134,498,499],{"class":136,"line":252},[134,500,374],{},[134,502,503],{"class":136,"line":258},[134,504,505],{},"M.mapNum = function(keysString)\n",[134,507,508],{"class":136,"line":264},[134,509,510],{},"    local str = \"\"\n",[134,512,513],{"class":136,"line":270},[134,514,515],{},"    for i = 1, #keysString do\n",[134,517,518],{"class":136,"line":276},[134,519,520],{},"        local prevPrevChar = i > 2 and keysString:sub(i - 2, i - 2) or nil\n",[134,522,523],{"class":136,"line":282},[134,524,237],{"emptyLinePlaceholder":236},[134,526,527],{"class":136,"line":288},[134,528,529],{},"        local prevChar = i > 1 and keysString:sub(i - 1, i - 1) or nil\n",[134,531,532],{"class":136,"line":294},[134,533,534],{},"        local char = keysString:sub(i, i)\n",[134,536,537],{"class":136,"line":300},[134,538,539],{},"        local isNumber = tonumber(char) ~= nil\n",[134,541,542],{"class":136,"line":306},[134,543,544],{},"        local prevIsNumber = prevChar ~= nil and tonumber(prevChar) ~= nil\n",[134,546,547],{"class":136,"line":312},[134,548,549],{},"        local prevIsAllowed = prevChar == nil or prevChar ~= \"F\" or prevIsNumber\n",[134,551,552],{"class":136,"line":318},[134,553,554],{},"        local prevPrevIsAllowed = prevPrevChar == nil or prevPrevChar ~= \"F\"\n",[134,556,557],{"class":136,"line":324},[134,558,559],{},"        if isNumber and prevIsAllowed and prevPrevIsAllowed then\n",[134,561,562],{"class":136,"line":330},[134,563,564],{},"            str = str .. replacements[char]\n",[134,566,567],{"class":136,"line":336},[134,568,569],{},"        else\n",[134,571,572],{"class":136,"line":342},[134,573,574],{},"            str = str .. char\n",[134,576,577],{"class":136,"line":348},[134,578,345],{},[134,580,581],{"class":136,"line":353},[134,582,309],{},[134,584,585],{"class":136,"line":359},[134,586,587],{},"    return config.baseSequence .. str\n",[134,589,590],{"class":136,"line":365},[134,591,356],{},[134,593,594],{"class":136,"line":371},[134,595,237],{"emptyLinePlaceholder":236},[134,597,598],{"class":136,"line":377},[134,599,600],{},"return M\n",[56,602,603],{},"It can then be used like so:",[125,605,607],{"className":127,"code":606,"language":129,"meta":130,"style":130},"local mn = require(\"utils\").mapNum\n\nvim.keymap.set(\"n\", mn(\"\u003CC-1>\"), ...)\n-- will not remap F1\nvim.keymap.set(\"n\", mn(\"\u003CC-F1>\"), ...) \n",[83,608,609,614,618,623,628],{"__ignoreMap":130},[134,610,611],{"class":136,"line":137},[134,612,613],{},"local mn = require(\"utils\").mapNum\n",[134,615,616],{"class":136,"line":143},[134,617,237],{"emptyLinePlaceholder":236},[134,619,620],{"class":136,"line":149},[134,621,622],{},"vim.keymap.set(\"n\", mn(\"\u003CC-1>\"), ...)\n",[134,624,625],{"class":136,"line":155},[134,626,627],{},"-- will not remap F1\n",[134,629,630],{"class":136,"line":161},[134,631,632],{},"vim.keymap.set(\"n\", mn(\"\u003CC-F1>\"), ...)\n",[56,634,635],{},"How to get a local module to actually load using lazy.nvim is out of scope for this post, but I might write one on that later because it was not very straightforward.",[637,638,639],"style",{},"html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}",{"title":130,"searchDepth":143,"depth":143,"links":641},[],"2023-07-01T00:00:00.000Z","Some lua functions to make it possible to use Modifier+Number shortcuts (e.g.Ctrl+1) in neovim.","md","/thumbs/neovim-wezterm-icon.png",[129],{},{"title":30,"description":643},[650,94],"neovim","ex7oItNe4bbo0isKb8cDzHrg7Onk28zCEFp4zS0I1ME",[653,655],{"title":26,"path":27,"stem":28,"description":654,"children":-1},"From zero C++ to getting a PR merged into Krita.",{"title":34,"path":35,"stem":36,"description":656,"children":-1},"Typescript's new satisfies is great for it's intended use case, but it's also great for the following use case.",1758977027527]